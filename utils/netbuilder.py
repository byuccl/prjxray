# netbuilder.py

# Cobbles together information from a segp file (generated by xray),
#   a logic_map.json file (created by get_logic.tcl), and the
#   tilegrid.json file (part of xray's database) to create a netlist

import json
import argparse

parser = argparse.ArgumentParser(description="Creates a netlist from xray files")
parser.add_argument("segp", help="*.segp file created by XRAY_SEGPRINT")
parser.add_argument("logic_map", help="logic_map.json file created by get_logic.tcl")
#For now I'll just expect the tilegrid file to be passed manually, but it may
#  be nice to ask instead for a target part and grab the tilegrid that way.
#  Maybe that's the makefile's job, though.
#Also note that this is the new tilegrid format 
parser.add_argument("tilegrid", help="tilegrid.json file from xray database")
parser.add_argument("-o", "--output", help="Output file")

args = parser.parse_args()

#print(args.segp)
#print(args.logic_map)
#print(args.tilegrid)

segp_f = open(args.segp)
lmap_f = open(args.logic_map)
tgrid_f = open(args.tilegrid)
out_f = None
if args.output:
    out_f = open(args.output, 'w')

# Read these files into useful data structures
# Fortunately, the json files should be easy to convert to dictionaries
lmap_d = json.load(lmap_f)
tgrid_d = json.load(tgrid_f)

# We shouldn't need lmap or tgrid files anymore
lmap_f.close()
tgrid_f.close()

# Read the segp file as a map of segments to tags. It might be worth
#   trying to come up with a better way to map out the tags themselves
#   eventually, but this will do for now...
segp_d = {}
currkey = ""
for line in segp_f:
    if len(line.split()) < 2: continue
    if line.split()[0] == "seg":
        currkey = line.split()[1][4:]
    elif line.split()[0] == "tag":
        if currkey not in segp_d:
            segp_d[currkey] = [line.split()[1]]
        else: segp_d[currkey].append(line.split()[1])

segp_f.close()

# for each entry in segp_d, go through the listed tags and (for now)
#   try to identify LUTs. For each LUT, read its equation and then try
#   to get derive the logical equation.

# Let's make a dict for keeping track of our LUTs
# Dict format is lut_d[slice][lutid][bit#], where lutid is "ALUT", etc
#   The bit# level is a list, not a dict.
# Like the segp file, a bit's presence means it is set. Hopefully this
#   is a good way to do this...
lut_d = {}

for seg in segp_d:
    for tag in segp_d[seg]:
        #Try to identify if this is a lut
        if tag.split(".")[2][1:] == "LUT":
            #Grab the corresponding slice from the tilegrid
            slicetype = tag.split(".")[1][:6] #Should be SLICEL/SLICEM
            sliceid = ""
            for site in tgrid_d[seg]["sites"]:
                if tgrid_d[seg]["sites"][site] == slicetype:
                    sliceid = site
                    #print("Found site",site,"for tag",tag)
            #I want to collate all bits in the LUT eq together into
            #  one object...
            if sliceid not in lut_d:
                lut_d[sliceid] = {}
            lutid = tag.split(".")[2]
            if lutid not in lut_d[sliceid]:
                lut_d[sliceid][lutid] = []
            bit = int(tag.split(".")[3][5:7])
            print("Adding slice",sliceid,"lut",lutid,"bit",bit,"to lut_d")
            lut_d[sliceid][lutid].append(bit)

cells_to_lut_data = {}
for slice in lut_d:
    for lut in lut_d[slice]:
        print("Looking at slice",slice,"lut",lut)
        # Let's try generating a full truth table. There's probably a way
        #   to do this without it, but I'm having a hard time thinking of
        #   what it may be
        # For now I'll assume 6 bit LUTs
        LUT_size = 6
        truth_table = [[0 for x in range(LUT_size + 1)] for y in range(2**LUT_size)]
        for i in range(2**LUT_size):
            # I need to convert i into binary (because that's the row's
            #   inputs)
            fstr = '0' + str(LUT_size) + 'b'
            bin_i = format(i, fstr)
            for bit in range(LUT_size):
                truth_table[i][bit] = int(bin_i[bit])
            if i in lut_d[slice][lut]:
                truth_table[i][LUT_size] = 1
            else:
                truth_table[i][LUT_size] = 0
        #print(truth_table)
        for row in truth_table:
            print(row)
        # Get a list of mapped values from the logic_map
        # This is a little awkward because it maps logical to physical, not
        #   vice versa
        pin_d = {}
        cell_name = ""
        for cell in lmap_d:
            # try to find a pin that actually has a physical equivalent
            #   (not all of them do)
            lpin = ""
            for logical_pin in lmap_d[cell]:
                if lmap_d[cell][logical_pin] != "":
                    lpin = logical_pin
                    break
            if lpin == "":
                # We didn't find any valid pins, just skip this cell
                print("WARNING: No physical pins found in cell",cell)
                continue
            c_slice = lmap_d[cell][lpin].split("/")[0]
            c_lut = lmap_d[cell][lpin].split("/")[1]
            if c_lut[2:] != "LUT": continue
            c_lut = c_lut[0]+c_lut[2:]
            if c_slice != slice: continue
            if c_lut != lut: continue
            # This should be a slice and lut that corresponds to the current
            #   slice/lut, so this (logical) cell maps to this lut.
            # Let's map the physical pins to the logical pins
            for lpin in lmap_d[cell]:
                pin_d[lmap_d[cell][lpin]] = lpin
            # Finally, let's note the logical cell name
            # There's actually an issue with using the logical cell names:
            #   multiple logical cells can apparently map to one BEL, so
            #   I can't really disambigulate them going backwards like this...
            cell_name = cell
        print("Got pin dict", pin_d)
        # I want to delete rows from the truth table that don't correspond to
        #   these inputs.
        # Again, this is kind of an issue with the possible many-to-one
        #   logical-to-phyiscal LUT mappings...
        # Also note that the indices here (A1, A2, ...) are 1 indexed.
        # Unfortunately, deleting a column invalidates our iterator, so
        #   we'll have to wrap this in another loop...
        tt_inputs = [i+1 for i in range(len(truth_table[0][0:-1]))]
        tt_inputs.reverse()
        print("Generated input list:",tt_inputs)
        done_deleting = False
        while not done_deleting:
            print("Current input list:", tt_inputs)
            done_deleting = True
            for tt_in in tt_inputs:
                if tt_in not in [int(inpin[-1:]) for inpin in \
                                 [pin for pin in pin_d if pin[-2] == 'A']]:
                    done_deleting = False
                    # Delete the i'th column from the truth table
                    print("deleting column", tt_in)
                    for row in truth_table:
                        del row[tt_inputs.index(tt_in)]
                    #Also remove it from our list of inputs
                    del tt_inputs[tt_inputs.index(tt_in)]
                    break
        #print(truth_table)
        for row in truth_table:
            print(row)

        # Delete duplicate rows in the truth table
        unique_rows = []
        to_del = [] #indices of rows to delete
        idx = 0
        for row in truth_table:
            if row not in unique_rows:
                unique_rows.append(row)
            else:
                #del truth_table[truth_table.index(row)]
                to_del.append(idx)
            idx += 1
        to_del.reverse() # keeps indices valid
        for idx in to_del:
            del truth_table[idx]
        print("Reduced Truth Table")
        for row in truth_table:
            print(row)

        # Re-order rows and columns to match logical ordering
        print("ttinputs:", tt_inputs)
        print(pin_d)
        # logical truth_table inputs
        tt_l_inputs = []
        input_pre_str = list(pin_d.keys())[0][:-2]+'A'
        for i in tt_inputs:
            dict_lookup = input_pre_str + str(i)
            dict_res = pin_d[dict_lookup]
            tt_l_inputs.append(int(dict_res[-1]))
        print("tt_l_inputs", tt_l_inputs)
        # Now re-order the columns so that the logical input list is in
        #   decending order
        for target in range(len(tt_l_inputs)):
            # We want to move the column under the "target" input
            #   to it's correct slot (which is
            #   truth_table[i][tt_width-2-target])
            # Get the current index of target
            cur_idx = tt_l_inputs.index(target)
            # Get the target index
            targ_idx = len(truth_table[0])-2-target
            if cur_idx == targ_idx: continue # It's already in the right spot
            # Go down the truth table and swap values
            tmp = tt_l_inputs[cur_idx]
            tt_l_inputs[cur_idx] = tt_l_inputs[targ_idx]
            tt_l_inputs[targ_idx] = tmp
            for row in truth_table:
                tmp = row[cur_idx]
                row[cur_idx] = row[targ_idx]
                row[targ_idx] = tmp
        print("Reorderd (col) truth table:")
        print(tt_l_inputs)
        for row in truth_table:
            print(row)
        # Now swap the rows so the row order is correct
        # The input columns should count up in binary
        for i in range(2**len(tt_l_inputs)):
            fstr = '0' + str(len(tt_l_inputs)) + 'b'
            bin_i = format(i, fstr)
            targ_row = [int(b) for b in bin_i]
            targ_row_idx = [row[:-1] for row in truth_table].index(targ_row)
            if targ_row_idx == i: continue
            tmp = truth_table[i]
            truth_table[i] = truth_table[targ_row_idx]
            truth_table[targ_row_idx] = tmp
        print("Fully ordered truth table:")
        for row in truth_table:
            print(row)

        # Finally, read up the last column of the truth table to get the
        #   LUT init value
        truth_table.reverse()
        init_val = 0
        for row in truth_table:
            init_val += row[len(row)-1]
            init_val = init_val << 1
        init_val = init_val >> 1
        print("Cell's init value:", format(init_val, 'x'))
        if cell_name in cells_to_lut_data:
            print("WARNING! Cell", cell_name,"is already in cells_to_inits dict!")
            print("         Overwriting old value!")
        cells_to_lut_data[cell_name] = (init_val, len(tt_l_inputs))
        
# Now try to print a verilog netlist file
# I don't really have many ways to differentiate the modules. I could grab the
#   module name from the "root" of the cell name, although I would prefer to
#   avoid relying on information from Vivado...
# What would happen if a design had multiple instances of the same module?

# For now, try clumping cells together based on their module instance.
mods_to_cells = {}
for cell in cells_to_lut_data:
    mod = cell.split("/")[0]
    if mod not in mods_to_cells:
        mods_to_cells[mod] = []
    mods_to_cells[mod].append(cell)

if out_f is not None:
    out_f.write("//Header...\n")
    out_f.write("`timescale 1 ps / 1 ps\n\n")
    
    for mod in mods_to_cells:
        out_f.write("module " + mod + "\n")
        # I need to figure out how to do the module i/o
        out_f.write("  (...)")
        out_f.write("\n")
        
        # I don't yet have interconnect information, so no wires
        out_f.write("  // Wires: \n\n")

        # LUT information
        # Again, this is still pretty limited
        out_f.write("  // LUTs:\n")
        for cell in cells_to_lut_data:
            lut_init = format(cells_to_lut_data[cell][0], 'X')
            lut_size = cells_to_lut_data[cell][1]
            out_f.write("  LUT" + str(lut_size) + " #(\n")
            out_f.write("    .INIT(" + str(2**lut_size) + "'h" + \
                        str(lut_init) + "))\n")
            out_f.write("    \\" + cell.split("/")[-1] + "\n")
            # Still no wires for io ports
            out_f.write("      ();\n")

    out_f.close()
